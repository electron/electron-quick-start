<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Numerical Characteristics of the Machine</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for .Machine {base}"><tr><td>.Machine {base}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Numerical Characteristics of the Machine</h2>

<h3>Description</h3>

<p><code>.Machine</code> is a variable holding information on the numerical
characteristics of the machine <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> is running on, such as the largest
double or integer and the machine's precision.
</p>


<h3>Usage</h3>

<pre>
.Machine
</pre>


<h3>Details</h3>

<p>The algorithm is based on Cody's (1988) subroutine MACHAR.  As all
current implementations of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> use 32-bit integers and use IEC 60559
floating-point (double precision) arithmetic, all but three of the
last four values are the same for almost all <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> builds. 
</p>
<p>Note that on most platforms smaller positive values than
<code>.Machine$double.xmin</code> can occur.  On a typical <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> platform the
smallest positive double is about <code>5e-324</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>double.eps</code></td>
<td>
<p>the smallest positive floating-point number
<code>x</code> such that <code>1 + x != 1</code>.  It equals
<code>double.base ^ ulp.digits</code> if either <code>double.base</code> is 2 or
<code>double.rounding</code> is 0;  otherwise, it is
<code>(double.base ^ double.ulp.digits) / 2</code>.  Normally
<code>2.220446e-16</code>.</p>
</td></tr>
<tr valign="top"><td><code>double.neg.eps</code></td>
<td>
<p>a small positive floating-point number <code>x</code>
such that <code>1 - x != 1</code>.  It equals
<code>double.base ^ double.neg.ulp.digits</code> if <code>double.base</code> is 2
or <code>double.rounding</code> is 0;  otherwise, it is
<code>(double.base ^ double.neg.ulp.digits) / 2</code>.  Normally
<code>1.110223e-16</code>. As <code>double.neg.ulp.digits</code> is bounded
below by <code>-(double.digits + 3)</code>, <code>double.neg.eps</code> may not
be the smallest number that can alter 1 by subtraction.</p>
</td></tr>
<tr valign="top"><td><code>double.xmin</code></td>
<td>
<p>the smallest non-zero normalized
floating-point number, a power of the radix, i.e.,
<code>double.base ^ double.min.exp</code>. Normally <code>2.225074e-308</code>.</p>
</td></tr>
<tr valign="top"><td><code>double.xmax</code></td>
<td>
<p>the largest normalized floating-point number.
Typically, it is equal to <code>(1 - double.neg.eps) *
      double.base ^ double.max.exp</code>, but
on some machines it is only the second or third largest such
number, being too small by 1 or 2 units in the last digit of the
significand.  Normally <code>1.797693e+308</code>.  Note that larger
unnormalized numbers can occur.</p>
</td></tr>
<tr valign="top"><td><code>double.base</code></td>
<td>
<p>the radix for the floating-point representation:
normally <code>2</code>.</p>
</td></tr>
<tr valign="top"><td><code>double.digits</code></td>
<td>
<p>the number of base digits in the floating-point
significand: normally <code>53</code>.</p>
</td></tr>
<tr valign="top"><td><code>double.rounding</code></td>
<td>
<p>the rounding action, one of<br />
0 if floating-point addition chops; <br />
1 if floating-point addition rounds, but not in the IEEE style; <br />
2 if floating-point addition rounds in the IEEE style; <br />
3 if floating-point addition chops, and there is partial underflow; <br />
4 if floating-point addition rounds, but not in the IEEE style, and
there is partial underflow; <br />
5 if floating-point addition rounds in the IEEE style, and there is
partial underflow.<br />
Normally <code>5</code>.</p>
</td></tr>
<tr valign="top"><td><code>double.guard</code></td>
<td>
<p>the number of guard digits for multiplication
with truncating arithmetic.  It is 1 if floating-point arithmetic
truncates and more than <code>double digits</code> base-<code>double.base</code> digits
participate in the post-normalization shift of the floating-point
significand in multiplication, and 0 otherwise.<br />
Normally <code>0</code>.</p>
</td></tr>
<tr valign="top"><td><code>double.ulp.digits</code></td>
<td>
<p>the largest negative integer <code>i</code> such
that <code>1 + double.base ^ i != 1</code>, except that it is bounded below by
<code>-(double.digits + 3)</code>.  Normally <code>-52</code>.</p>
</td></tr>
<tr valign="top"><td><code>double.neg.ulp.digits</code></td>
<td>
<p>the largest negative integer <code>i</code>
such that <code>1 - double.base ^ i != 1</code>, except that it is bounded
below by <code>-(double.digits + 3)</code>. Normally <code>-53</code>.</p>
</td></tr>
<tr valign="top"><td><code>double.exponent</code></td>
<td>

<p>the number of bits (decimal places if <code>double.base</code> is 10) reserved
for the representation of the exponent (including the bias or sign)
of a floating-point number.  Normally <code>11</code>.</p>
</td></tr>
<tr valign="top"><td><code>double.min.exp</code></td>
<td>

<p>the largest in magnitude negative integer <code>i</code> such that
<code>double.base ^ i</code> is positive and normalized.  Normally <code>-1022</code>.</p>
</td></tr>
<tr valign="top"><td><code>double.max.exp</code></td>
<td>

<p>the smallest positive power of <code>double.base</code> that overflows.  Normally
<code>1024</code>.</p>
</td></tr>
<tr valign="top"><td><code>integer.max</code></td>
<td>
<p>the largest integer which can be represented.
Always <i>2^31 - 1 = 2147483647</i>.</p>
</td></tr>
<tr valign="top"><td><code>sizeof.long</code></td>
<td>
<p>the number of bytes in a C <code>long</code> type:
<code>4</code> or <code>8</code> (most 64-bit systems, but not Windows).</p>
</td></tr>
<tr valign="top"><td><code>sizeof.longlong</code></td>
<td>
<p>the number of bytes in a C <code>long long</code>
type.  Will be zero if there is no such type, otherwise usually
<code>8</code>.</p>
</td></tr>
<tr valign="top"><td><code>sizeof.longdouble</code></td>
<td>
<p>the number of bytes in a C <code>long double</code>
type.  Will be zero if there is no such type (or its use was
disabled when <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> was built), otherwise possibly
<code>12</code> (most 32-bit builds) or <code>16</code> (most 64-bit builds).</p>
</td></tr>
<tr valign="top"><td><code>sizeof.pointer</code></td>
<td>
<p>the number of bytes in a C <code>SEXP</code>
type.  Will be <code>4</code> on 32-bit builds and <code>8</code> on 64-bit
builds of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>sizeof.longdouble</code> only tells you the amount of storage
allocated for a long double (which are normally used internally by <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> for
accumulators in e.g. <code><a href="sum.html">sum</a></code>, and can be read by
<code><a href="readBin.html">readBin</a></code>).  Often what is stored is the 80-bit extended
double type of IEC 60559, padded to the double alignment used on the
platform &mdash; this seems to be the case for the common <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> platforms
using ix86 and x86_64 chips.
</p>


<h3>Source</h3>

<p>Uses a C translation of Fortran code in the reference, modified by the
R Core Team to defeat over-optimization in recent compilers.
</p>


<h3>References</h3>

<p>Cody, W. J. (1988).
MACHAR: A subroutine to dynamically determine machine parameters.
<em>Transactions on Mathematical Software</em>, <b>14</b>(4), 303&ndash;311.
doi: <a href="https://doi.org/10.1145/50063.51907">10.1145/50063.51907</a>.
</p>


<h3>See Also</h3>

<p><code><a href="Platform.html">.Platform</a></code> for details of the platform.
</p>


<h3>Examples</h3>

<pre>
.Machine
## or for a neat printout
noquote(unlist(format(.Machine)))
</pre>

<hr /><div style="text-align: center;">[Package <em>base</em> version 3.6.1 <a href="00Index.html">Index</a>]</div>
</body></html>
